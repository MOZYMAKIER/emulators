<!doctype html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        layout {
            display: flex;
            flex-direction: column;
        }
    </style>
    <script src="../emulators.js"></script>
    <script src="stats.min.js"></script>
</head>

<body>
    <div class="layout">
        <div id="controls">
            <button onClick="javascript:downloadBundleAndRun({worker: true})">Start Worker</button>
            <button onClick="javascript:downloadBundleAndRun({worker: false})">Start Direct</button>
        </div>
        <p>FRAME:</p>
        <canvas id="canvas"></canvas>
        <p>STDOUT:</p>
        <pre id="stdout"></pre>
    </div>

    <script>
        emulators.pathPrefix = "../";

        const stats = new Stats();
        stats.showPanel(0);
        stats.dom.style.left = "initial";
        stats.dom.style.right = "0px";
        document.body.appendChild(stats.dom);

        let runId = 0;
        async function runBundle(bundle, options) {
            const id = runId++;
            const stdout = document.getElementById("stdout");
            const canvas = document.getElementById("canvas");
            const gl = canvas.getContext("webgl");

            // promise is resolved when emulator is started
            const ci = await (options.worker ?
                emulators.dosWorker(bundle) :
                emulators.dosDirect(bundle));

            webGl(canvas, ci);

            ci.events().onStdout((message) => {
                stdout.innerHTML += message;
            });

            function getKeyCode(code) {
                switch (code) {
                    case 13: return 257;
                    case 38: return 265;
                    case 39: return 262;
                    case 37: return 263;
                    case 40: return 264;
                    case 17: return 341;
                    default: return code;
                }
            }

            window.addEventListener("keydown", (e) => {
                ci.sendKeyEvent(getKeyCode(e.keyCode), true);
                e.stopPropagation();
            });
            window.addEventListener("keyup", (e) => {
                ci.sendKeyEvent(getKeyCode(e.keyCode), false);
                e.stopPropagation();
            });
        }

        function downloadBundleAndRun(options) {
            document.getElementById("controls").style.display = "none";
            const bundleUrl = "temp.jsdos?timestamp=" + Date.now();

            // we need to download bundle, emulators accept only Uint8Array
            const xhr = new XMLHttpRequest();
            xhr.open("GET", bundleUrl, true);
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
            xhr.responseType = "arraybuffer";
            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    // do not forget to create Uint8Array, 
                    // arraybuffer will not work!
                    runBundle(new Uint8Array(xhr.response), options);
                }
            };
            xhr.send();
        };

        const vsSource = `
attribute vec4 aVertexPosition;
attribute vec2 aTextureCoord;

varying highp vec2 vTextureCoord;

void main(void) {
  gl_Position = aVertexPosition;
  vTextureCoord = aTextureCoord;
}
`;

        const fsSource = `
varying highp vec2 vTextureCoord;
uniform sampler2D uSampler;


void main(void) {
  highp vec4 color = texture2D(uSampler, vTextureCoord);
  gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
}
`;

        function webGl(canvas, ci) {
            const gl = canvas.getContext("webgl");
            if (gl === null) {
                throw new Error("Unable to create webgl context on given canvas");
            }

            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            const vertexPosition = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            const textureCoord = gl.getAttribLocation(shaderProgram, "aTextureCoord");
            const uSampler = gl.getUniformLocation(shaderProgram, "uSampler");

            initBuffers(gl, vertexPosition, textureCoord);

            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            const pixel = new Uint8Array([0, 0, 0]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB,
                1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE,
                pixel);

            gl.useProgram(shaderProgram);
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uSampler, 0);

            let frameWidth = 0;
            let frameHeight = 0;

            const onResize = () => {
                canvas.style.width = frameWidth + "px";
                canvas.style.height = frameHeight + "px";
            };

            const onResizeFrame = (w, h) => {
                frameWidth = w;
                frameHeight = h;
                canvas.width = frameWidth;
                canvas.height = frameHeight;
                gl.viewport(0, 0, frameWidth, frameHeight);
                onResize();
            };

            ci.events().onFrameSize(onResizeFrame);
            onResizeFrame(ci.width(), ci.height());

            let requestAnimationFrameId = null;
            let frameRgb = null;
            ci.events().onFrame((rgb) => {
                frameRgb = rgb;
                if (requestAnimationFrameId === null) {
                    requestAnimationFrameId = requestAnimationFrame(updateTexture);
                }
            });

            function updateTexture() {
                stats.update();

                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB,
                    frameWidth, frameHeight, 0, gl.RGB, gl.UNSIGNED_BYTE,
                    frameRgb);
                gl.drawArrays(gl.TRIANGLES, 0, 6);

                requestAnimationFrameId = null;
                frameRgb = null;
            }
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                throw new Error("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
            }

            return shaderProgram;
        }

        function loadShader(gl, shaderType, source) {
            const shader = gl.createShader(shaderType);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error("An error occurred compiling the shaders: " + info);
            }

            return shader;
        }

        function initBuffers(gl, vertexPosition, textureCoord) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [
                -1.0, -1.0, 0.0,
                1.0, -1.0, 0.0,
                1.0, 1.0, 0.0,
                -1.0, -1.0, 0.0,
                1.0, 1.0, 0.0,
                -1.0, 1.0, 0.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);

            const textureCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
            const textureCoordinates = [
                0.0, 1.0,
                1.0, 1.0,
                1.0, 0.0,
                0.0, 1.0,
                1.0, 0.0,
                0.0, 0.0,
            ];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                gl.STATIC_DRAW);

            gl.vertexAttribPointer(textureCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(textureCoord);
        }
    </script>
</body>

</html>